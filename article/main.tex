\documentclass[a4paper, 12pt]{article}
% \usepackage{ae,lmodern}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[USenglish]{babel}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{todonotes}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}


\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section] % Number within sec ?
% \newtheorem{theorem}{Theorem}
\newtheorem{prop}[theorem]{Proposition}
\newtheorem{property}[theorem]{Property}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{observation}[theorem]{Observation}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}
% \newtheorem*{remark*}{Remark}
% \theoremstyle{definition}
% \newtheorem{problem}{Problem}
% \newtheorem{openproblem}{Open Problem}

\newcommand{\NN}{\mathbb{N}}%
\newcommand{\ZZ}{\mathbb{Z}}%
\newcommand{\Sbb}{\mathbb{S}}%
\newcommand{\Cc}{\mathcal{C}}%
\newcommand{\Gg}{\mathcal{G}}%
\newcommand{\Ff}{\mathcal{F}}%
\newcommand{\Ss}{\mathcal{S}}%
\newcommand{\eps}{\varepsilon}%
\newcommand{\epsm}{\eps^{-1}}%
\newcommand{\bit}{\{0,1\}}%
\DeclareMathOperator*{\poly}{poly}

\newcommand{\Omegat}[1]{\widetilde{\Omega}\left( #1 \right)}%
\newcommand{\Ot}[1]{\widetilde{O}\left( #1 \right)}%

\newcommand{\Poly}{\textsf{P}}%
\newcommand{\NP}{\textsf{NP}}%
\newcommand{\NTIME}{\textsf{NTIME}}%
\newcommand{\SAT}{\textsf{SAT}}%
\newcommand{\ParSAT}{\ensuremath\bigoplus\textsf{SAT}}%
\newcommand{\SharpSAT}{\#\textsf{SAT}}%
\newcommand{\NAND}{\textsf{NAND}}%

%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
\title{Uniform formula lower bounds for finding and counting satisfiable assignments}
\author{Gabriel Bathie, Ryan Williams}
\begin{document}
\maketitle

\begin{abstract}
\end{abstract}


List of things to do:
\begin{itemize}
	\item Improve Spira/Brent to show that a $c \log n$ depth 
	lower bound implies an $n^{c-\eps}$ size lower bound?
	\item Show that this bound is optimal w.r.t. these rules?
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Motivation: understanding complexity. Explicit lower bounds : programs, circuits, formulas.
Uniformity.

Related work:
- Original line of work : \cite{fortnow2000time,fortnow2005time}
- Main line of work \cite{williams2006inductive,williams2007time,williams2013alternation} and its dramatic resolution \cite{buss2015limits}.
- Broader classes \cite{mudigonda2020time}

Best known formula lower bounds for languages (functions?) in NP: 
\begin{itemize}
	\item $\Omegat{n^3}$ (for both uniform and non-uniform formulas) for Andreev's function \cite{hastad1998shrinkage}\todo{check source} in the De Morgan basis $\{\wedge, \vee, \neg\}$.
	\item $\Omega{n^2/\log n}$ in the full binary basis (Nechiporuk)
	\item $n^{\Theta(\log n)}$ for monotone formulas (formulas over the $\{\wedge, \vee\}$ basis).
\end{itemize}

\subsection{Results overview}

We first study \NAND{} formulas. 
The \NAND{} basis is rather expressive: Andreev's function has \NAND{} formulas of depth $(3+o(1)) \log n$ (and therefore of size $\Ot{n^3}$), which matches the lower bound for the De Morgan Basis.


\begin{theorem}
	For any $c < 4 \cos(\pi/7) \simeq 3.603$, \SAT does not have \NAND{} formulas of depth $(c + o(1)) \log n$.
\end{theorem}

\todo[inline]{Prove all of the following.

After checking \cite{sergeev2019relation}, this is probably incorrect...}
\begin{lemma}
	For any \NAND{} formula on $n$ inputs of size $n^c$ and any $\eps > 0$, 
	there exists an equivalent \NAND{} formula of depth $(c+\eps) \log n$.
\end{lemma}

\begin{corollary}
	For any $c < 4 \cos(\pi/7)$, \SAT does not have \NAND{} formulas of \textbf{size} $n^{c + o(1)}$.
\end{corollary}

\begin{theorem} (??)
	With our rules, we cannot do better than $4 \cos(\pi/7)$.
\end{theorem}

%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
\section{Definitions}
Notations?

Uniform \NAND{}/alternating formulas. Specific model, comparison with the usual model.

\subsection{Alternating computation}

Given a complexity class $\Cc$ and a constant $c$, we consider \textit{quantified} complexity
class $(Q~n^c)~\Cc$, where $Q$ is one of $\forall, \exists$ or $\oplus$.
We define them as follows:
\begin{definition}[Quantified classes]
	A language $L$ is in $(Q~n^c)~\Cc$ if and only if there exists a RAM machine
	that runs in time $n^{c + o(1)}$...

	Problem with this definition: size of the input $n$ is not the same at every stage.
\end{definition}

\subsection{Overview of the methodology}
Approach: proof by contradiction.

%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
\section{Proof of thm}
Speedup Rule for Alternating formulas.

Slowdown Rule from algorithms for SAT assumptions:
\begin{lemma}
	Let $\Ff$ be a class of formulas closed under composition that can simulate projections in constant depth.
	If $\SAT\in \Ff[c \log n]$, then $\NTIME[n] \subseteq \Ff[c \log n]$.
\end{lemma}
\begin{proof}
	This follows from the fact that $\SAT$ is \NP-complete under uniform poly-log time first-order projections.
\end{proof}

Can we say the same for $\ParSAT$ and $\SharpSAT$?

How to get the contradiction given the slowdown rule for $c < 4\cos(\pi /7)$.

\subsection{Improving Brent/Spira}
\todo[inline]{Prove this}
Useful starting point : Size-Depth Tradeoffs for Boolean Formulae (Bonet, Buss).

Remark: we must focus on the case when the input formula is a \NAND{} formula.
Otherwise, we prove a much stronger result.
Maybe prove the stronger result with a $2+\eps$ factor? Not very useful though.
If we can go below 2, we improve something.
%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
\section{Proof of optimality}
\todo[inline]{Prove this}


%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain}
\bibliography{biblio.bib}

\end{document}
